\subsection{Class Module}\label{Module}
This class represents the concept of a single source file. Currently, Modules are only identified for the executable file; each shared library is made up of a single Module, ignoring any source file information that may be present. We also create a single module, called DEFAULT\_MODULE, for each Symtab that contains any symbols for which module information was unavailable. This may be compiler template code, or files produced without module information. 

\begin{center}
\begin{tabular}{ll}
\toprule
supportedLanguages & Meaning \\
\midrule
lang\_Unknown & Unknown source language \\
lang\_Assembly & Raw assembly code \\
lang\_C & C source code \\
lang\_CPlusPlus & C++ source code \\
lang\_GnuCPlusPlus & C++ with GNU extensions \\
lang\_Fortran & Fortran source code \\
lang\_Fortran\_with\_pretty\_debug & Fortran with debug annotations \\
lang\_CMFortran & Fortran with CM extensions \\
\bottomrule
\end{tabular}
\end{center}

\begin{tabular}{p{1.25in}p{1.25in}p{3in}}
	Method name & Return type & Method description \\
	\hline
	isShared & bool & True if the module is for a shared library, false for an executable. \\
	fullName & std::string \& & Name, including path, of the source file represented by the module. \\
	fileName & std::string \& & Name, not including path, of the source file represented by the module. \\
	language & supportedLanguages & The source language used by the Module. \\
	addr & Offset & Offset of the start of the module, as reported by the symbol table, assuming contiguous modules. \\
	exec & Symtab * & Symtab object that contains the module. \\
	hasLineInformation & bool & True if the module has line information. \\
\end{tabular}


\paragraph{Function, Variable, Symbol lookup}

\begin{apient}
bool findFunctionByEntryOffset(Function *&ret, const Offset offset)
\end{apient}
\apidesc{
This method returns the Function object that begins at offset. Returns true on
success and false if there is no matching function. The error value is set to
No\_Such\_Function.
}

\begin{apient}
typedef enum {
    mangledName,
    prettyName,
    typedName,
    anyName
} NameType;
\end{apient}

\begin{apient}
bool findFunctionsByName(vector<Function> &ret, const string name,
                         Symtab::NameType nameType = anyName,
                         bool isRegex = false, bool checkCase = true)
\end{apient}
\apidesc{
This method finds and returns a vector of Functions whose names match the given pattern. The nameType parameter determines which names are searched: mangled, pretty, typed, or any. If the isRegex flag is set a regular expression match is performed with the symbol names. checkCase is applicable only if isRegex has been set. This indicates if the case be considered while performing regular expression matching. ret contains the list of matching Functions, if any.
Returns true if it finds functions that match the given name, otherwise returns
false. The error value is set to No\_Such\_Function.
}

\begin{apient}
bool getAllFunctions(vector<Function *> &ret)
\end{apient}
\apidesc{
This method returns all functions in the object file. Returns true on success
and false if there are no modules. The error value is set to No\_Such\_Function.
}

\begin{apient}
bool findVariableByOffset(Variable *&ret, const Offset offset)
\end{apient}
\apidesc{
This method returns the Variable object at offset. Returns true on success and
false if there is no matching variable. The error value is set to No\_Such\_Variable.
}

\begin{apient}
bool findVariablesByName(vector<Function> &ret, const string &name,
                        Symtab::NameType nameType,
                        bool isRegex = false, bool checkCase = true)
\end{apient}
\apidesc{
This method finds and returns a vector of Variables whose names match the given pattern. The nameType parameter determines which names are searched: mangled, pretty, typed, or any (note: a Variable may not have a typed name). If the isRegex flag is set a regular expression match is performed with the symbol names. checkCase is applicable only if isRegex has been set. This indicates if the case be considered while performing regular expression matching. ret contains the list of matching Variables, if any.
Returns true if it finds variables that match the given name, otherwise returns
false. The error value is set to No\_Such\_Variable.
}

\begin{apient}
bool getAllVariables(vector<Variable *> &ret)
\end{apient}
\apidesc{
This method returns all variables in the object file. Returns true on success
and false if there are no modules. The error value is set to No\_Such\_Variable.
}

\begin{apient}
bool getAllSymbols(vector<Symbol *> &ret)
\end{apient}
\apidesc{
This method returns all symbols.
Returns true on success and false if there are no symbols. The error value is
set to No\_Such\_Symbol.
}

\begin{apient}
bool getAllSymbolsByType(vector<Symbol *> &ret, 
 Symbol::SymbolType sType)
\end{apient}
\apidesc{
This method returns all symbols whose type matches the given type sType.
Returns true on success and false if there are no symbols with the given type.
The error value is set to No\_Such\_Symbol.}

\paragraph{Line number information}


\begin{apient}
bool getAddressRanges(vector< pair<unsigned long, unsigned long> > & ranges, 
                    string lineSource, unsigned int LineNo)
\end{apient}
\apidesc{
This method returns the address ranges in ranges corresponding to the line with line number lineNo in the source file lineSource. Searches only this module for the given source.
Return true if at least one address range corresponding to the line number was found and returns false if none found.
}

\begin{apient}
bool getSourceLines(vector<Statement *> &lines, Offset addressInRange)
\end{apient}
\apidesc{
This method returns the source file names and line numbers corresponding to the given address addressInRange. Searches only this module for the given source. 
Return true if at least one tuple corresponding to the offset was found and returns false if none found. The \code{Statement} class used to be named \code{LineNoTuple}; backwards compatibility is provided via typedef. 
}

\begin{apient}
LineInformation *getLineInformation() const
\end{apient}
\apidesc{
This method returns the line map (section \ref{LineInformation}) corresponding to the module. Returns NULL if
there is no line information existing for the module.}

\begin{apient}
bool getStatements(std::vector<Statement *> &statements)
\end{apient}
\apidesc{
Returns all line information  (section \ref{Statement}) available for the module.
}

\paragraph{Type information}

\begin{apient}
bool findType(Type *&type, string name)
\end{apient}
\apidesc{
This method performs a look up and returns a handle to the named type. 
This method searches all the built-in types, standard types and user-defined types within the module. Returns true if a type is found with type containing the handle to the type, else return false.
}

\begin{apient}
bool findLocalVariable(vector<localVar *> &vars, string name)
\end{apient}
\apidesc{
The method returns a list of local variables within the module with name name. 
Returns true with vars containing a list of localVar objects corresponding to the local variables if found or else returns false.
}

\begin{apient}
bool findVariableType(Type *&type, std::string name)
\end{apient}
\apidesc{
This method looks up a global variable with name name and returns its type attribute.
Returns true if a variable is found or returns false with type set to NULL.}
