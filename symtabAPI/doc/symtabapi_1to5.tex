\section{Introduction}
\label{sec:intro}

SymtabAPI is a multi-platform library for parsing symbol tables,
object file headers and debug information. SymtabAPI currently
supports the ELF (IA-32, AMD-64, and POWER), XCOFF (POWER), and PE
(Windows) object file formats. In addition, it also supports the DWARF
and stabs debugging formats.

The main goal of this API is to provide an abstract view of binaries and
libraries across multiple platforms. An abstract interface provides two
benefits: it simplifies the development of a tool since the complexity of a
particular file format is hidden, and it allows tools to be easily ported
between platforms. Each binary object file is represented in a canonical
platform independent manner by the API. The canonical format consists of four
components: a header block that contains general information about the object
(e.g., its name and location), a set of symbol lists that index symbols within
the object for fast lookup, debug information (type, line number and local
variable information) present in the object file and a set of additional data
that represents information that may be present in the object (e.g., relocation
or exception information). Adding a new format requires no changes to the
interface and hence will not affect any of the tools that use the SymtabAPI. 

Our other design goal with SymtabAPI is to allow user and tool developers to
easily extend or add symbol or debug information to the library through a
platform-independent interface. Often times it is impossible to satify all the
requirements of a tool that uses SymtabAPI, as those requirements can vary from
tool to tool. So by providing extensible structures, SymtabAPI allows tools to
modify any structure to fit their own requirements. Also, tools frequently use
more sophisticated analyses to augment the information available from the binary
directly; it should be possible to make this extra information available to the
SymtabAPI library. An example of this is a tool operating on a stripped binary.
Although the symbols for the majority of functions in the binary may be missing,
many can be determined via more sophisticated analysis. In our model, the tool
would then inform the SymtabAPI library of the presence of these functions; this
information would be incorporated and available for subsequent analysis. Other
examples of such extensions might involve creating and adding new types or
adding new local variables to certain functions.

This document describes SymtabAPI, an Application Program Interface (API) for
parsing object files or binaries, for querying symbols and debug information,
and for interacting with the library to add, remove or change symbols or other
useful information.  The SymtabAPI interface is designed to be small and easy to
understand, while remaining sufficiently expressive to be useful for a variety
of applications. The way we have done this is by providing a simple set of
abstractions and a simple way to interact with the API. 

\section{Abstractions}
\label{sec:intro}

\begin{figure}
    \caption{SymtabAPI Object Ownership Diagram}
    \label{fig:object-ownership}
\end{figure}

SymtabAPI provides a simple set of abstractions over complicated data structures
which makes it straight-forward to use. The SymtabAPI consists of four
interfaces : the symbol table interface, the type interface, the line map
interface and the local variable interface. 

Figure~\ref{fig:object-ownership} shows the ownership hierarchy for the
SymtabAPI classes. Ownership here is a ``contains'' relationship; if one
class owns another, then instances of the owner class maintain an exclusive
instance of the other. For example, each Symtab class instance contains multiple
instances of class Symbol and each Symbol class instance belongs to one Symtab
class instance. Each of four interfaces and the classes belonging to these
interfaces are described in the rest of the section. The API functions in each
of the classes are described in detail in Section 6.

\subsection{Symbol Table Interface}

The symbol table interface is responsible for parsing the object file and
handling the look-up and addition of new symbols. It is also responsible for the
emit functionality that SymtabAPI supports. The Symtab and the Module classes
inherit from the LookupInterface class, an abstract class, ensuring the same
lookup function signatures for both Module and Symtab classes. 

\begin{description}
\item[Symtab] A Symtab class object represents either an object file on-disk or in-memory that the SymtabAPI library operates on.
\item[Symbol] A Symbol class object represents an entry in the symbol table.
\item[Function] A Function class object identifies a function within the binary object.
\item[Variable] A Variable class object identifies variable within the binary object.
\item[Module] A Module class object represents a particular source file in cases where multiple files were compiled into a single binary object; if this information is not present, we use a single default module.
\item[Archive] An Archive class object represents a collection of binary objects stored in a single file (e.g., a static archive). 
\item[ExceptionBlock] An ExceptionBlock class object represents an exception block which contains the information necessary for run-time exception handling.
\end{description}

\subsection{Type Interface}
 The Type interface is responsible for parsing type information from the object file and handling the look-up and addition of new type information. Figure 2 shows the class inheritance diagram for the type interface. Class Type is the base class for all of the classes that are part of the interface. This class provides the basic common functionality for all the types, such as querying the name and size of a type. The rest of the classes represent specific types and provide more functionality based on the type. 

 \begin{figure}
     \caption{SymtabAPI Type Interface - Class Inheritance Diagram}
     \label{fig:class-inherit}
 \end{figure}

Some of the types inherit from a second level of type classes, each representing a separate category of types. 
\begin{description}
\item[fieldListType] - This category of types represent the container types that contain a list of fields. Examples of this category include structure and the union types. 
\item[derivedType] - This category of types represent types derived from a base type. Examples of this category include typedef, pointer and reference types. 
\item[rangedType] - This category represents range types. Examples of this category include the array and the sub-range types. 
\end{description}
The enum, function, common block and scalar types do not fall under any of the above category of types. Each of the specific types is derived from Type.

\subsection{Line Number Interface}

The Line Number interface is responsible for parsing line number information from the object file debug information and handling the look-up and addition of new line information. The main classes for this interface are LineInformation and LineNoTuple. 

\begin{description}
\item[LineInformation] - A LineInformation class object represents a mapping of line numbers to address range within a module (source file). 
\item[LineNoTuple] - A LineNoTuple class object represents a location in source code with a source file, line number in that source file and start column in that line.
\end{description}

\subsection{Local Variable Interface}
The Local Variable Interface is responsible for parsing local variable and parameter information of functions from the object file debug information and handling the look-up and addition of new add new local variables. All the local variables within a function are tied to the Symbol class object representing that function.
\begin{description}
\item[localVar] - A localVar class object represents a local variable or a parameter belonging to a function.
\end{description}

\subsection{Dynamic Address Translation}
The AddressLookup class is a component for mapping between absolute addresses found in a running process and SymtabAPI objects. This is useful because libraries can load at different addresses in different processes. Each AddressLookup instance is associated with, and provides mapping for, one process.

\section{Simple Examples}

To illustrate the ideas in the API, this section presents several short examples
that demonstrate how the API can be used.  SymtabAPI has the ability to parse
files that are on-disk or present in memory. The user program starts by
requesting SymtabAPI to parse an object file. SymtabAPI returns a handle if the
parsing succeeds, whcih can be used for further interactions with the SymtabAPI
library. The following example shows how to parse a shared object file on disk.

\lstset{language=[GNU]C++,basicstyle=\fontfamily{fvm}\selectfont\small}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=5, numbersep=5pt}
\begin{lstlisting}
using namespace Dyninst;
using namespace SymtabAPI;

//Name the object file to be parsed:
std::string file = libfoo.so;

//Declare a pointer to an object of type Symtab; this represents the file.
Symtab *obj = NULL;

// Parse the object file
bool err = Symtab::openFile(file, obj);
\end{lstlisting}

Once the object file is parsed successfully and the handle is obtained, symbol look up and update operations can be performed in the following way:

\begin{lstlisting}
using namespace Dyninst;
using namespace SymtabAPI;
std::vector <Symbol *> syms;
std::vector <Function *> funcs;

// search for a function with demangled (pretty) name bar.
if (obj->findFunctionsByName(funcs, bar)) {
       // Add a new (mangled) name to the first function
       funcs[0]->addMangledName(newname);
}

// search for symbol of any type with demangled (pretty) name bar.
if (obj->findSymbolByType(syms, "bar", Symbol::ST_UNKNOWN)) {

// change the type of the found symbol to type variable(ST_OBJECT)
syms[0]->setType(Symbol::ST_OBJECT);

// These changes are automatically added to symtabAPI; no further
// actions are required by the user.
}
\end{lstlisting}

New symbols, functions, and variables can be created and added to the library at any point using the handle returned by successful parsing of the object file. When possible, add a function or variable rather than a symbol directly. 

\begin{lstlisting}
using namespace Dyninst;
using namespace SymtabAPI;

//Module for the symbol
Module *mod;

//obj represents a handle to a parsed object file.
//Lookup module handle for DEFAULT_MODULE 
obj->findModule(mod, DEFAULT_MODULE);

// Create a new function symbol
Variable *newVar = mod->createVariable(newIntVar,  // Name of new variable
                                       0x12345,      // Offset from data section
                                       sizeof(int)); // Size of symbol 
\end{lstlisting}

SymtabAPI gives the ability to query type information present in the object file. Also, new user defined types can be added to SymtabAPI. The following example shows both how to query type information after an object file is successfully parsed and also add a new structure type.

\begin{lstlisting}
// create a new struct Type
// typedef struct{
//int field1,
//int field2[10]
// } struct1;

using namespace Dyninst;
using namespace SymtabAPI;

// obj represents a handle to a parsed object file using SymtabAPI
// Find a handle to the integer type
Type *lookupType;
obj->findType(int, lookupType);

// Convert the generic type object to the specific scalar type object
typeScalar *intType = lookupType->getScalarType()

// container to hold names and types of the new structure type
vector<pair<string, Type *> >fields;

//create a new array type(int type2[10])
typeArray *intArray = typeArray::create(obj,intArray,intType,0,9);

//types of the structure fields
fields.push_back(pair<string, Type *>(field1, intType));
fields.push_back(pair<string, Type *>(field2, intArray));

//create the structure type
typeStruct *struct1 = typeStruct::create(obj, struct1, fields, obj);
\end{lstlisting}

Users can also query line number information present in an object file. The following example shows how to use SymtabAPI to get the address range for a line number within a source file.

\begin{lstlisting}
using namespace Dyninst;
using namespace SymtabAPI;

// obj represents a handle to a parsed object file using symtabAPI
// Container to hold the address range
vector< pair< Offset, Offset > > ranges;

// Get the address range for the line 30 in source file foo.c
obj->getAddressRanges( "foo.c", 30, ranges );
\end{lstlisting}

Local variable information can be obtained using symtabAPI. You can query for a local variable within the entire object file or just within a function. The following example shows how to find local variable foo within function bar.

\begin{lstlisting}
using namespace Dyninst;
using namespace SymtabAPI;

// Obj represents a handle to a parsed object file using symtabAPI
// Get the Symbol object representing function bar
vector<Symbol *> syms;
obj->findSymbolByType(syms, bar, Symbol::ST_FUNCTION);

// Find the local var foo within function bar
vector<localVar *> *vars = syms[0]->findLocalVarible(foo);
\end{lstlisting}

Parsing an XCOFF object file is different than the rest of the file formats as the XCOFF format also allows archives to contain dynamic libraries. The following examples shows how to open an XCOFF archive using SymtabAPI on AIX.

\begin{lstlisting}
//Name the object file to be parsed
std::string file = libfoo.a

// Declare a pointer to an object of type Archive. This represents the archive.
Archive *archive = NULL;

// Declare an pointer to an object of type Symtab. This represents the object.
Symtab *obj = NULL;

// Try to parse the archive file; error handling omitted for simplicity
Archive::openArchive(file, archive);

// Get the Symtab object for the desired object
archive->getMember(bar.o, obj);
// Obj now contains a handle to the desired binary object bar.o
\end{lstlisting}

The rest of this document describes the class hierarchy and the API in detail.

\section{Definitions and Basic Types}

The following definitions and basic types are referenced throughout the rest of this document.

\subsection{Definitions}

\begin{description}
\item[Offset] - Offsets represent an address relative to the start address(base) of the object file. For executables, the Offset represents an absolute address.
The following definitions deal with the symbol table interface.
\item[Object File] - An object file is the representation of code that a compiler or assembler generates by processing a source code file. It represents .os, a.outs and shared libraries.
\item[Region] - A region represents a contiguous area of the file that contains executable code or readable data.
\item[Symbol] - A symbol represents an entry in the symbol table, and may identify a function, variable or other structure within the file.
\item[Function] - A function represents a code object within the file represented by one or more symbols.
\item[Variable] - A variable represents a data object within the file represented by one or more symbols.
\item[Module] - A module represents a particular source file in cases where multiple files were compiled into a single binary object; if this information is not present, or if the binary object is a shared library, we use a single default module.
\item[Archive] - An archive represents a collection of binary objects stored in a single file (e.g., a static archive). 
\item[Relocations] - These provide the necessary information for inter-object references between two object files. 
\item[Exception Blocks] - These contain the information necessary for run-time exception handling
The following definitions deal with members of the Symbol class.
\item[Mangled Name] - A mangled name for a symbol provides a way of encoding additional information about a function, structure, class or another data type in a symbol name. It is a technique used to solve various problems caused by the need to resolve unique names for programming entities in many modern programming languages. For example, a function foo with signature void foo() has a mangled name $_Z8foov$ when compiled with gcc.
\item[Pretty Name] - A pretty name for a symbol represents a user-level symbolic name for a symbol. For example, foo can be a pretty name for a function declared as void foo().
\item[Typed Name] - A typed name for a symbol represents the user-level symbolic name complete with the signature. For example, void foo() can be a typed name for the function foo.
\item[Symbol Linkage] - The symbol linkage for a symbol gives information on the visibility (binding) of this symbol, whether it is visible only in the object file where it is defined (local), if it is visible to all the object files that are being linked (global), or if its a weak alias to a global symbol.
\item[Symbol Type] - Symbol type for a symbol represents the category of symbols to which it belongs. It can be a function symbol or a variable symbol or a module symbol.
The following definitions deal with the type and the local variable interface.
\item[Type] - A type represents the data type of a variable or a parameter. This can represent language pre-defined types (e.g. int, float), pre-defined types in the object (e.g., structures or unions), or user-defined types.
\item[Local Variable] - A local variable represents a variable that has been declared within the scope of a sub-routine or a parameter to a sub-routine.
\end{description}

\subsection{Basic Types}

\begin{apient}
typedef unsigned long Offset
\end{apient}
\apidesc{An integer value that contains an offset from base address of the object file.}
\begin{apient}
typedef int typeId_t
\end{apient}
\apidesc{A unique handle for identifying a type. Each of types is assigned a globally unique ID. This way it is easier to identify any data type of a variable or a parameter.}
\begin{apient}
typedef ... PID
\end{apient}
\apidesc{A handle for identifying a process that is used by the Dynamic Components of SymtabAPI. On UNIX platforms PID is a int, on Windows it is a HANDLE that refers to a process.}
\begin{apient}
typedef unsigned long Address
\end{apient}
\apidesc{An integer value that represents an address in a process. This is used by the Dynamic Components of SymtabAPI.}

\section{Namespace SymtabAPI}

The classes described in Section 6 are under the C++ namespace Dyninst::SymtabAPI. To access them a user should refer to them using the Dyninst:: and SymtabAPI:: prefixs, e.g. Dyninst::SymtabAPI::Type. Alternatively, a user can add the C++ using keyword above any references to SymtabAPI objects, e.g, using namespace Dyninst and using namespace SymtabAPI.

