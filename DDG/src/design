Design notes on a basic block summary, iterator based design. 

Design goals:
 * Memory efficiency
     Keeping around instruction or operation-level data in the DDG
     will result in a number of nodes equal to 3 or 4 times the 
     number of instructions (at least 1, 3-4x is a guess). The cost per
     node is 2 words (Address, Absloc pointer minimum) plus edges. The
     likely cost is substantially higher.
 * Reasonable CPU usage
     CPU is cheaper than memory in modern systems. However, we still 
     need to be efficient with the processor. 
 * Matching common usage patterns
     I hypothesize that most uses of a DDG are slicing or a similar
     one-pass algorithm. 

Consider a function with a single basic block. We can generate the 
DDG within the function with a single pass. No fixpoint is required
since there are no instructions with multiple predecessors. Therefore
the following are equivalent:

A graph of nodes
 * O(1) to generate the graph
 * O(n) to traverse
 * O(n) memory required
A summary at entry
 * O(n) to generate the graph
 * O(n) to traverse
 * O(a) memory required (a = number of used abstract locations)

If we assume that a << n then the second option is vastly preferred. This
can easily be verified. I hypothesize this is the case; typically, a
basic block operates on a small set of variables and hence registers.
