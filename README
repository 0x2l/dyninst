READ THIS FIRST: how to build DyninstAPI and its subcomponents

1) Configuration

Dyninst is now built via CMake. We recommend performing an interactive
configuration with "ccmake ." first, in order to see which options are
relevant for your system. You may also perform a batch configuration
with "cmake .".  Options are passed to CMake with -DVAR=VALUE. Common
options include:

Boost_INCLUDE_DIR 
CMAKE_BUILD_TYPE 
CMAKE_INSTALL_PREFIX
LIBDWARF_INCLUDE_DIR 
LIBDWARF_LIBRARIES 
LIBELF_INCLUDE_DIR
LIBELF_LIBRARIES 
IBERTY_LIBRARIES

CMake's default generator on Linux is normally "Unix Makefiles", and
on Windows, it will normally produce project files for the most recent
version of Visual Studio on your system. Other generators should work
but are not tested. After the CMake step concludes, you will have
appropriate Makefiles or equivalent and can build Dyninst.

We require CMake 2.6 as a minimum on all systems, and CMake 2.8.11
allows us to automatically download and build libelf/libdwarf/binutils
on ELF systems if they are needed. If you do not have a sufficiently
recent CMake, you may need to manually specify the location of these
dependencies.

2) Building and installation

To build Dyninst and all its components, "make && make install" from
the top-level directory of the source tree. To build and install a
single component and its dependencies, do the same thing from that
component's subdirectory. Libraries will be installed into
CMAKE_INSTALL_PREFIX/INSTALL_LIB_DIR, and headers will be installed
into CMAKE_INSTALL_PREFIX/INSTALL_INCLUDE_DIR. If you wish to import
Dyninst into your own CMake projects, the export information is in
CMAKE_INSTALL_PREFIX/INSTALL_CMAKE_DIR. PDF documentation is included
and installed to CMAKE_INSTALL_PREFIX/INSTALL_DOC_DIR. If you update
the LaTeX source documents for any manuals, "make doc" will rebuild
them. Components may be built and installed individually: "make
$COMPONENT" and "make $COMPONENT-install" respectively; this will
appropriately respect inter-component dependencies.

3) What's new

SIGNIFICANT CAPABILITY CHANGES

* Dyninst now allows modification of the stack frames of
  functions. See the manual for details.

* SD-Dyninst is now integrated into the Dyninst main line. See the
  manual for details.

* Machine learning based gap parsing rules are now integrated into
  Dyninst, and no longer need to be compiler-specific. Gap parsing
  should find significantly more function entry points, particularly
  when run on code generated by non-GNU compilers.

* SymtabAPI now provides information about inlined functions. See the
  manual for details.

* SymtabAPI (in read-only mode), ProcControl, and Stackwalker (in
  3rd-party mode) now work on ARM64 Linux.

* Loops are now represented in ParseAPI and PatchAPI, as well as at
  the BPatch level. The loop interface has been extended to represent
  irreducible loops correctly; see the manual for details.

PERFORMANCE/CORRECTNESS IMPROVEMENTS

* Indirect control flow is now analyzed by a principled, slicing-based
  approach and its accuracy is substantially improved.

* SymtabAPI and ParseAPI should consume much less memory for
  representing symbols, symbol indexes, line information, block
  extents, and function extents. There will be a small CPU penalty
  when opening files under SymtabAPI in exchange for this.

GENERAL BUG FIXES

* Fixes in ProcControl's exit handling code.

