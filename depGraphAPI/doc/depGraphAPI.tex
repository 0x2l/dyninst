\documentclass[12pt,titlepage]{article}
\usepackage{fullpage}
\usepackage{epsfig}
\usepackage{subfigure}
\begin{document}
\title{Dependence Graph API (DepGraphAPI) Programmer's Guide \\ Release 0.9b}
\author{Paradyn Parallel Performance Tools}
\maketitle
\tableofcontents
\section{Introduction}

The DepGraphAPI is a multi-platform library for creating and analyzing
dependence graph representations of binary code. A dependence graph is
a representation of must-happen-before and must-happen-after
relationships between program elements such as instructions and basic
blocks. A program may consist of several logically separate streams
of execution that are interleaved by the compiler; dependence graph
representations undo this interleaving. We represent
relationships in terms of a \emph{graph}, a data structure that
consists of nodes connected by directed edges. Nodes in the graph
represent program elements and edges represent \emph{dependences}
(must-happen-before or must-happen-after) between
elements.

The DepGraphAPI currently provides four graph representations:
\begin{description}
\item[Data Dependence Graph (DDG)] This graph represents the relations
between instructions that define and instructions that use registers
and memory. Nodes in this graph represent instructions, and edges
connect definitions of a particular location to its uses.
\item[Control Dependence Graph (CDG)] This graph represents
conditional execution of basic blocks in the program.
\item[Program Dependence Graph (PDG)] This graph is the union of the
DDG and CDG, used to compute a \emph{program slice} (defined below).
\item[Extended Program Dependence Graph (xPDG)] This graph is the PDG
augmented with additional nodes and edges necessary for forming an
\emph{executable slice} (defined in Section \ref{ExecutableSlice}.
\end{description}

The main goal of this API is to provide the user with abstractions
representing the logical dependencies between code elements in a
program. An abstract interface provides two benefits: it simplifies
the development of tools by hiding the complexity of a particular
architecture, and it allows tools to easily be ported
between platforms. Using a dependence graph representation of a
program allows the user to focus on a particular aspect of program
behavior and ignore program elements that do not affect that aspect of
behavior.

\textbf{Program Slice}: An excellent example of the use of the program
dependence graph is the \emph{program slice}, or more commonly just
``slice''. Intuitively, a slice of a program from a particular point
is the sub-program that affects that point (a backward slice) or is
affected by that point (a forward slice). Formally, we define slices
as follows. Let $i$ represent an instruction in the program and $a$
some location that $i$ defines (writes a value into).  The backward
slice from $(i,a)$ are all instructions (and defined locations) that
may affect the value written into $a$ by $i$.  A forward slice from
$(i,a)$ are all instructions (and defined locations) that may be
affected by the definition of $a$ by $i$.

A future goal of this library is to allow users to improve the
precision of these graph representations through the use of additional
analyses. The included analyses used to generate these graph
representations are conservative, and may overapproximate the actual
dependences between instructions. A future release will provide API
extensions for updating these graph structures, either with
information known to the user directly, with the results of more
sophisticated static analysis, or with dynamic analysis results.

The current beta of the DepGraphAPI depends on the InstructionAPI
library and the DyninstAPI; future versions will depend only on the
InstructionAPI and ParsingAPI libraries released as part of the
DyninstAPI. Currently we support the IA-32 and AMD-64 architectures as
these are the only architectures supported by the
InstructionAPI. Future architecture support will include PowerPC, IA-64,
and SPARC. The DepGraphAPI has no file format or operating system
constraints.

\section{Definitions}

\begin{description}
\item[Instruction] An instruction represents a single machine
instruction with a unique starting offset. Instruction instances are
identified by this offset.
\item[Basic Block] A basic block is a contiguous sequence of
  instructions with the property that if the first instruction in the
  block is executed all other instructions will be executed before the
  block is exited.
\item[Function] A function is a collection of basic blocks with a
  single entry block. Functions are frequently reached by call
  instructions, although this may not be the case due to compiler
  optimizations. Similarly, functions are frequently exited via return
  instructions, but other exit methods may be used by the compiler.
\item[Abstract Location] An abstract location represents a machine
register, memory location, or set of memory locations. Registers are
referred to by their InstructionAPI representation. Memory locations
consist of a region and an optional offset within that region. Regions
include the stack, the heap, and global memory. Stack locations are
assumed to be relative from the top of the stack at the beginning of
the function. Our current implementation assumes a single heap
location; this may change in future releases. Finally, offsets into
global memory are absolute addresses from a base of zero.
\item[Operation] An operation is a pair of an instruction and an
abstract location defined by that instruction. An instruction may
define more than one abstract location, particularly on CISC
architectures. If we represent data dependence at the instruction
level we may overapproximate dependences between instructions; we
describe an example of this occurrence in Section
\ref{OperationJustification}. Instead we represent dependences at the
operation level.
\item[Parameters] The parameters to a function consist of all abstract
  locations that may be used by an instruction in the function without
  having been defined by an instruction in the function.
\item[Results] The results of a function consist of all abstract
  locations that are defined by that function.
\item[Data Dependence] In general, instruction $j$ is data dependent
  on an instruction $i$ if $i$ defines some abstract location $a$, $j$
  uses $a$, and there is an execution path from $i$ to $j$ along which
  $a$ is not redefined. We use a more precise definition that uses
  operations instead of instructions. Let $m = (i,a)$ be an operation
  representing the definition of $a$ by $i$, and similarly for $n =
  (j, b)$. Then $n$ is data dependent on $m$ if $i$ defines $a$, $j$
  uses $a$ to define $b$, and there exists a path as above. Note that
  $j$ may define other abstract locations, but no data dependence will
  exist if $a$ is not used in these other definitions.
\item[Control Dependence] An instruction $j$ is control dependent on
  an instruction $i$ if $i$ has multiple successors and $j$ is
  executed along at least one, but not all, possible execution paths
  from $i$.

\end{description}

\begin{figure}
\begin{center}
  \subfigure[Instruction nodes]{\label{ddg-a}\includegraphics[scale=0.75]{figs/DDG-a.pdf}}
  \subfigure[Operation
  nodes]{\label{ddg-b}\includegraphics[scale=0.75]{figs/DDG-b.pdf}}
\end{center}
\caption{Example of instruction vs. operation-based DDG. Figure a)
provides an example of the problems of representing instructions as
single nodes. In this graph it is possible for paths to ``cross''
definitions; for example, there is a path from the definition of $r_0$
by $i_0$ to the definition of $sp$ (the stack pointer) by $i_3$, when
in the actual program there is no such dependence. The DDG shown in
figure b) makes the intra-instruction data dependencies explicit and
thus removes the possibility of erroneous paths.}
\label{OperationsGraph}
\end{figure}


\subsection{Operation-Level Data Dependence}\label{OperationJustification}

The conventional definition of the DDG (in which nodes represent
instructions) may over-approximate the data dependencies within a
binary. This occurs when an instruction defines multiple abstract
locations and uses different sets of abstract locations for each
definition. For example, consider the IA-32 instruction xchng which
exchanges the contents of two registers. From an instruction
perspective, this instruction uses and defines two registers. However,
there is no dependence between the use and definition of the same
registers. To avoid this over-approximation, each node in the
DepGraphAPI DDG consists of an operation; an (instruction, abstract
location) pair. We show an example of the use of instructions and
operations in Figure \ref{OperationsGraph}.


\section{Abstractions}

DepGraphAPI provides a simple set of abstractions over complicated
data structures to make the API easy to use. We first define these
abstractions in terms of concepts; the classes that implement these
concepts are defined below. The fundamental representation used by
this library is the directed graph (or digraph). A digraph is a set of
nodes connected by directed edges; each edge has a single source and
target. Nodes represent logical elements of the program. We define two
types of nodes: \emph{physical} and \emph{virtual}.  We provide a set
of methods for operating on Graphs, Nodes, and Edges; these methods
provide a common interface to all four dependence graph types provided
by the DepGraphAPI.

\subsection{Graph Abstractions}
\begin{description}
\item[Graph] A graph is a collection of nodes connected by directed
  edges; each edge has a unique source and target node. Graphs have a
  set of entry nodes, from which all nodes are reachable by following
  edges forward, and exit nodes, from which all nodes are reachable by
  following edges backward.
\item[Node] We define two types of nodes: physical and
  virtual. Physical nodes represent a particular instruction, basic
  block, or function. Virtual nodes represent the behavior of code
  that is not directly represented by a physical node. Virtual nodes
  represent a summary of the behavior of code that is not contained
  within the graph, such as the behavior of a called function, the
  assignment of values to the parameters of a function, or the use of
  values returned from a function. For example, let \texttt{foo} be a
  function that calls \texttt{bar}. A DDG for function \texttt{foo}
  would include physical nodes for the code within \texttt{foo}, but
  not for the code in \texttt{bar}. Instead, the behavior of
  \texttt{bar} would be represented by one or more virtual nodes.
\item[Edge] Edges connect nodes and represent a dependence between the
  two connected nodes.
\end{description}

Figure \ref{inheritance} shows the inheritance hierarchy for the
DepGraphAPI classes. All references to DepGraphAPI classes are
internally reference counted; we do not require the user to perform
any manual memory allocation or deletion.

\begin{figure}
\begin{center}
\includegraphics[scale=0.75]{figs/Inheritance.pdf}
\caption{Inheritance diagram for the DepGraphAPI. The Graph, Node, and
  Edge classes provide a common interface specification. The DDG, CDG,
  PDG, and xPDG graphs customize these three classes as necessary.}
\end{center}
\label{inheritance}
\end{figure}

\subsection{Shared Class}

\begin{description}
\item[Graph] The Graph represents a dependence graph for a particular
function.
\item[Node] The Node represents an element within the graph. Nodes are
connected by edges and are labelled with information.
\item[PhysicalNode] These Nodes represent an element (instruction,
basic block, or function) of the program. They are labelled with the
starting address of that object.
\item[VirtualNode] These Nodes represent summaries of program behavior
not contained within the graph. Virtual nodes do not have an address
associated with them.
\item[Edge] Edges connect Nodes. Edges are directed and have a source
and target.
\end{description}

\subsection{Data Dependence Graph}

The data dependence graph adds five specialized node types. 

\begin{description}
\item[OperationNode] Each physical DDG node represents an operation (a
definition of an abstract location by an instruction). We describe
operations and our justification of this abstraction in Section
\ref{OperationJustification}.
\item[FormalParameterNode] A formal parameter node represents the
  input parameters to a function. One of these nodes will exist in the
  graph for each abstract location that is used without having first
  been defined by the function. These are virtual nodes, and form a
  subset of the entry nodes of the DDG.
\item[FormalReturnNode] A formal return node represents the values
  returned by the function; this includes any explicit return result
  register as well as all other definitions that may persist after the
  function returns. These are virtual nodes, and form a subset of the
  exit nodes of the DDG.
\item[ActualParameterNode] These virtual nodes represent abstract
  locations used by a callee function.
\item[ActualReturnNode] These virtual nodes represent abstract
  locations defined by a callee function.
\end{description}

\subsection{Control Dependence Graph}

The control dependence graph adds one new specialized node type:

\begin{description}
\item[BlockNode] We represent
control dependence at the basic block level for efficiency. Therefore, each
node in the CDG represents a block. 
\end{description}

\subsection{Program Dependence Graph}
The Program Dependence Graph is the union of the DDG and CDG and is
constructed from the same abstractions used by the DDG. The basic
block-level information in the CDG is automatically converted to
OperationNodes.

\subsection{Extended Program Dependence Graph}
Although users can use PDGs to slice programs, the slices obtained
through PDGs are not always executable slices due to the presence of
unconditional branches. An executable slice is a slice of a program
that can be executed without any change in program behavior with
respect to the given slicing criteria. Program slices obtained through
the PDG will not include branch instructions that do not depend on the
slicing target; however, these branch instructions are necessary to
ensure proper control flow. Therefore, we augment the PDG to create
the Extended Program Dependence Graph (xPDG). The xPDG adds
dependence edges between branches and and all other instructions in
the basic block that ends at the branch. 

\section{Examples} 

To illustrate the ideas in the API, we present two short examples that
demonstrate how the API can be used.

\begin{figure}
\include{include/example1}
\caption{Slicing example. This code fragment identifies the nodes
  reachable by following edges forward from the node with address
  \texttt{insnAddr}.}
\label{example1}
\end{figure}

Our first example demonstrates how to access the PDG for a particular
function and take a slice from a known instruction (identified by its
address) and register that the instruction defines. The code for this
example is shown in Figure \ref{example1}. Lines of interest are:
\begin{itemize}
\item Line 16 identifies all nodes with a particular address
  \texttt{insnAddr}. The set of these nodes is represented by the pair
  of iterators \texttt{nodeBegin} and \texttt{nodeEnd}.
\item Line 19 determines whether there were nodes at the given
  address. If the iterators are equal the range is empty.
\item Line 25 determines the set of nodes reachable from the given
  node (the \emph{forward closure} from the node). The statement
  \texttt{*nodeBegin} returns the first node from the set identified
  in line 16. As before, the closure is represented by an iterator
  pair \texttt{sliceBegin, sliceEnd}. 
\item Line 28 shows how to iterate over the forward closure. The
  iterator \texttt{sliceBegin} will represent each node in the
  closure; the sequence in which the nodes are returned is
  undefined. Each node can be accessed by dereferencing the iterator:
  \texttt{*sliceBegin}.
\end{itemize}

\begin{figure}
\include{include/example2}
\caption{DDG traversal example. This code fragment identifies nodes
  within a basic block that have a data dependence to themselves.}
\label{example2}
\end{figure}

The second example shows how to determine which instructions in a
basic block that have a data dependence to themselves; that is, they
define and use the same abstract location. This is one method to
identify a loop iteration variable. The code for this example is shown
in Figure \ref{example2}. Lines of interest are:
\begin{itemize}
\item Line 15 shows how to access the instructions in a basic
  block. The \texttt{InsnInstance} typedef consists of an
  InstructionAPI instruction object and the address of the
  instruction. We use these addresses to identify nodes within the
  graph.
\item Line 18 shows how to iterate over each instruction in the block.
\item Line 23 shows how to find the set of nodes representing each
  instruction. Since the DDG may represent a single instruction as
  multiple operation nodes this set may have multiple elements. 
\item Line 26 shows how to get the targets of a node. These targets
  can be represented either as a set of edges or a set of nodes,
  whichever is convenient. 
\item Line 28 identifies nodes that have edges to themselves; that is,
  nodes that define themselves. 
\end{itemize}


\section{Definitions and Basic Types}

The DepGraphAPI supplies four types of dependence graphs. We define
these forms of dependence here, along with definitions of the
underlying concepts. The following definitions and basic types are
referenced throughout the rest of the document.

\subsection{Basic Types}

{\ttfamily \raggedright \small
typedef\ \textbf{unsigned}\ \textbf{long}\ Address\\
 }
\normalfont\normalsize
\indent An integer value that represents a unique location in memory.\\[\baselineskip]
\noindent \textbf{Smart/shared pointers}

All objects returned to users are transparently wrapped with a
reference counted pointer implementation. This smart pointer
automatically handles deallocation and garbage collection. These
pointers are referred to by the \texttt{::Ptr} suffix (e.g., \texttt{Graph::Ptr},
\texttt{Node::Ptr}, etc.). Our implementation is derived from the Boost
\texttt{shared\_ptr} implementation; for more information, please visit
www.boost.org. Shared pointers have some limitations when compared
with standard pointers. In particular, \texttt{dynamic\_cast} (as well as other
casting operators) are not defined on shared pointers. Performing such
a cast must be done with the \texttt{dynamic\_pointer\_cast}
method. For example: \indent {\ttfamily \raggedright \small
VirtualNode::Ptr\ virt\ =\ dynamic\underline\ pointer\underline\ cast<{}VirtualNode>{}(nodePtr);} \\[\baselineskip]
\normalfont\normalsize 
\noindent \textbf{Iterators}

The DepGraphAPI uses an iterator-based interface in favor of a
collection-based interface. This is done to reduce copying and improve
efficiency. Any method that returns a range of objects (e.g.,
\texttt{Graph::allNodes}) takes as arguments two iterators that are updated to
point to the beginning and end of the range. The user can then use
standard iterator methods (e.g., a for loop) to examine each element
in the range. We define two types of iterators: \texttt{NodeIterator} and
\texttt{EdgeIterator}.

\section{API Reference}

This section describes the interface of the DepGraphAPI. Each of the
subsections represents a different interface.

The classes described in this section are defined in the \texttt{Dyninst::} and
\texttt{Dyninst::DepGraphAPI::} namespaces.  To access them a user
should refer to them using the appropriate prefix (e.g.,
\texttt{Dyninst::Graph} or
\texttt{Dyninst::DepGraphAPI::DDG}). Alternatively, a user can add the
C++ \texttt{using} keyword above any reference to such objects (e.g.,
"\texttt{using namespace Dyninst;}").  The Graph, Node, and Edge
classes are contained in the \texttt{Dyninst::} namespace.  All other
classes are defined under the \texttt{Dyninst::DepGraphAPI} namespace.

        
\subsection{Shared Classes}

The \texttt{Graph}, \texttt{Node}, and \texttt{Edge} classes are written to be generic and
shareable between DyninstAPI components. We include the API for these
classes here.

\subsubsection{Graph}

\begin{description}

\item[void entryNodes(NodeIterator \&begin, NodeIterator \&end)] This
method returns a range of nodes (defined by \texttt{begin} and
\texttt{end}) such that 1) all nodes in the graph are reachable from
the nodes in this range by traversing out-edges and 2) the range is
minimal. The nodes included in this range may be virtual.
\item[void exitNodes(NodeIterator \&begin, NodeIterator \&end)] This
method returns a range of nodes (defined by \texttt{begin} and
\texttt{end}) such that 1) all nodes in the graph are reachable from
the nodes in this range by traversing in-edges and 2) the range is
minimal. The nodes included in this range may be virtual.
\item[void allNodes (NodeIterator \&begin, NodeIterator \&end)]
This method returns the range of all nodes in the graph.
\item[void printDOT(std::string fileName)]
This method generates a representation of the graph in DOT format.
\item[bool find(Address addr, NodeIterator \&begin, NodeIterator \&end)]
This method sets \texttt{begin} and \texttt{end} to point to a range
representing the nodes with a particular address. It returns true if
the range is non-empty. 
\item[void removeAnnotation()] This method removes the graph from
internal storage. Once all user handles to the graph are discarded the
graph will be destroyed.
\end{description}

\subsubsection{Node}

\begin{description}
\item[bool hasInEdges()] This method returns true if the node has at
  least one in edge. 
\item[void ins(EdgeIterator \&begin, EdgeIterator \&end)]
This method returns the range of in edges to the node (edges that have the node as a target). 
\item[void ins(NodeIterator \&begin, NodeIterator \&end)]
This method is similar to the previous, but automatically traverses the edges and returns a range of source nodes. 
\item[bool hasOutEdges()] This method returns true if the node has at
  least one out edge. 
\item[void outs(EdgeIterator \&begin, EdgeIterator \&end)]
This method returns the range of out edges from the node (edges that have the node as a source). 
\item[void outs(NodeIterator \&begin, NodeIterator \&end)]
This method is similar to the previous, but automatically traverses the edges and returns a range of target nodes.
\item[void forwardClosure(NodeIterator \&begin, NodeIterator \&end)]
This method returns all nodes reachable from this node in the forward direction (by traversing out-edges).
\item[void backwardsClosure(NodeIterator \&begin, NodeIterator \&end)]
This method returns all nodes reachable from this node by traversing in-edges.
\item[Graph::Ptr forwardSubgraph()]
This method constructs and returns the subgraph that includes all
nodes reachable from the current node along forward edges.
\item[Graph::Ptr backwardSubgraph()]
This method constructs and returns the subgraph that includes all
nodes reachable from the current node along forward edges.
\item[std::string format()]
This method returns a textual representation of the node.
\item[bool isVirtual() ]
This method returns true if a node is virtual.
\end{description}

\subsubsection{PhysicalNode : Node}
\begin{description}
\item[Address addr()] This method returns the starting
offset of the code object (basic block, instruction, or operation) the
node represents.
\item[bool isVirtual()] This method returns false for physical nodes.
\end{description}

\subsubsection{VirtualNode : Node}
\begin{description}
\item[bool isVirtual()]
This method always returns true for virtual nodes.
\end{description}

\subsubsection{Edge}
\begin{description}
\item[Node::Ptr source()]
This method returns the source node of an edge.
\item[Node::Ptr target() ]
This method returns the target node of an edge.
\end{description}

\subsection{Data Dependence Graph}
\subsubsection{DDG}
\begin{description}
\item[DDG::Ptr analyze(BPatch\_function *func)]
This method creates and returns a DDG for the provided function.
\item[void formalParamNodes(NodeIterator \&begin, NodeIterator \&end) ]
This method returns the range of all formal parameters to the function.
\item[void formalReturnNodes(NodeIterator \&begin, NodeIterator \&end)]
This method returns the range of all formal returns from the function.
\item[void actualParamNodes(Address callAddr, NodeIterator \&begin, NodeIterator \&end) ]
This method returns the range of all actual parameters for the call instruction
at the given address.
\item[void actualReturnNodes(Address callAddr, NodeIterator \&begin, NodeIterator \&end)]
This method returns the range of all actual returns for the call instruction at
the given address.
\item[bool find(Address addr, Absloc::Ptr absloc, NodeIterator \&begin, NodeIterator \&end) ]
This method returns the range of nodes that fit the specific address
and absloc requirements. This range will contain at most one
element. It returns true if the range is non-empty, and false
otherwise. 
\item[DDG::Ptr removeDeadNodes()] This method constructs a derived DDG
  that contains no dead nodes. All nodes that cannot reach a
  formal return node are removed. This includes definitions to
  abstract locations that are redefined before being used. 
\item[void immediateDefinitions(NodeIterator \&begin, NodeIterator
  \&end)] This method returns the range of non-formal-parameter nodes
  that have no in-edges. This occurs when an instruction defines an
  abstract location without using any other abstract location; for
  example, \texttt{mov \$42, eax}. Using this in combination with
  \texttt{formalParamNodes} will give the set of entry nodes to the DDG.
\item[void deadDefinitions(NodeIterator \&begin, NodeIterator \&end)]
  This method gives the range of non-formal-return nodes that have no
  out-edges. This occurs when a node defines an abstract location that
  is redefined before being used. These dead definitions are commonly
  instruction side-effects (e.g., ignored writes to the flags). 
\end{description}

\subsubsection{Absloc}
\begin{description}
\item[std:string format()]
This method returns a textual representation of the abstract location. This representation is guaranteed to be unique for unique abstract locations.
\item[void getAliases(AbslocIterator \&begin, AbslocIterator \&end)]
If more than one Absloc may refer to the same abstract location (e.g., a particular stack slot and the representation of the entire stack) return any such aliases.
\item[bool isPrecise()]
This method returns true if the absloc does not contain any others; that is, if any aliases are more general than this one.
\end{description}

\subsubsection{OperationNode : PhysicalNode}
\begin{description}
\item[Absloc::Ptr absloc()]
This method returns the abstract location represented by this node.
\end{description}

\subsubsection{FormalParameterNode : VirtualNode}
\begin{description}
\item[Absloc::Ptr absloc()]
This method returns the abstract location represented by this node. 
\end{description}

\subsubsection{FormalReturnNode : VirtualNode}
\begin{description}
\item[Absloc::Ptr absloc()]
This method returns the abstract location represented by this node.
\end{description}

\subsubsection{ActualParameterNode : VirtualNode}
\begin{description}
\item[Absloc::Ptr absloc()]
This method returns the abstract location represented by this node.
\item[BPatch\_function *callee() ]
This method returns the callee function whose argument is represented by this node.
\end{description}

\subsubsection{ActualReturnNode : VirtualNode}
\begin{description}
\item[Absloc::Ptr absloc()]
This method returns the abstract location represented by this node.
\item[BPatch\_function *callee() ]
This method returns the callee function whose return is represented by this node.
\end{description}

\subsection{Control Dependence Graph}
\subsubsection{CDG}
\begin{description}
\item[CDG::Ptr analyze(BPatch\_function *func)]
This method creates and returns a CDG for the provided function.
\item[bool find(BPatch\_basicBlock *block, NodeIterator \&begin, NodeIterator \&end)]
This method returns the range of nodes representing the provided
block. This range will have at most one element. It returns true if
the range is non-empty and false otherwise. 
\item[bool find(Address addr, NodeIterator \&begin, NodeIterator
\&end)] This method returns the range of nodes containing the provided
address. It returns true if the range is non-empty and false
otherwise.
\end{description}

\subsubsection{BlockNode : Node}
\begin{description}
\item[BPatch\_basicBlock *block() ]
This method returns the basic block represented by this node. 
\end{description}

\subsection{Program Dependence Graph}
\subsubsection{PDG}
\begin{description}
\item[PDG::Ptr analyze(BPatch\_function *func)]
Creates and returns a PDG for the provided function.
\item[find(Address addr, Absloc::Ptr absloc, NodeIterator \&begin, NodeIterator \&end) ]
This method returns the set of nodes that fit the specific address and absloc requirements. This node will be singular.
\end{description}

\subsection{Extended Program Dependence Graph}
\subsubsection{xPDG}
\begin{description}
\item[xPDG::Ptr analyze(BPatch\_function *func)]
Creates and returns an xPDG for the provided function.
\item[find(Address addr, Absloc::Ptr absloc, NodeIterator \&begin, NodeIterator \&end) ]
This method returns the set of nodes that fit the specific address and absloc requirements. This node will be singular.
\end{description}

\section{Implementation Status}

This release of the DepGraphAPI is a public beta and has limited
platform support and implementation features. These limitations are as
follows:
\begin{itemize}
\item Platforms: the DepGraphAPI is implemented for IA-32 and
  x86-64. This is primarily due to a dependence on the InstructionAPI.
\end{itemize}


\section{Building DepGraphAPI}
This appendix describes how to build DepGraphAPI from source code,
which can be downloaded from http://www.paradyn.org or
http://www.dyninst.org.

\subsection{Building on Unix}
The beta of the DepGraphAPI depends on the DyninstAPI. It is currently
packaged with the DyninstAPI source tree. It can be built using the
DepGraphAPI make target once the DyninstAPI has been built and
installed.

\end{document}
